{"lessons-5":{
"5a8b073d06fa14fcfde687aa" : {"id":"5a8b073d06fa14fcfde687aa","title":"Exercise Tracker","videoUrl":"","content":"\nBuild a full stack JavaScript app that is functionally similar to this: <a href='https://fuschia-custard.glitch.me/' target='_blank'>https://fuschia-custard.glitch.me/</a>.\nWorking on this project will involve you writing your code on Glitch on our starter project. After completing this project you can copy your public glitch url (to the homepage of your app) into this screen to test it! Optionally you may choose to write your project on another platform but it must be publicly visible for our testing.\nStart this project on Glitch using <a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-project-exercisetracker/' target='_blank'>this link</a> or clone <a href='https://github.com/freeCodeCamp/boilerplate-project-exercisetracker/'>this repository</a> on GitHub! If you use Glitch, remember to save the link to your project somewhere safe!\n"},
"bd7158d8c443edefaeb5bd0f" : {"id":"bd7158d8c443edefaeb5bd0f","title":"File Metadata Microservice","videoUrl":"","content":"\nBuild a full stack JavaScript app that is functionally similar to this: <a href='https://purple-paladin.glitch.me/' target='_blank'>https://purple-paladin.glitch.me/</a>.\nWorking on this project will involve you writing your code on Glitch on our starter project. After completing this project you can copy your public glitch url (to the homepage of your app) into this screen to test it! Optionally you may choose to write your project on another platform but it must be publicly visible for our testing.\nStart this project on Glitch using <a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-project-filemetadata/' target='_blank'>this link</a> or clone <a href='https://github.com/freeCodeCamp/boilerplate-project-filemetadata/'>this repository</a> on GitHub! If you use Glitch, remember to save the link to your project somewhere safe!\n"},
"bd7158d8c443edefaeb5bdff" : {"id":"bd7158d8c443edefaeb5bdff","title":"Request Header Parser Microservice","videoUrl":"","content":"\nBuild a full stack JavaScript app that is functionally similar to this: <a href='https://dandelion-roar.glitch.me/' target='_blank'>https://dandelion-roar.glitch.me/</a>.\nWorking on this project will involve you writing your code on Glitch on our starter project. After completing this project you can copy your public glitch url (to the homepage of your app) into this screen to test it! Optionally you may choose to write your project on another platform but it must be publicly visible for our testing.\nStart this project on Glitch using <a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-project-headerparser/' target='_blank'>this link</a> or clone <a href='https://github.com/freeCodeCamp/boilerplate-project-headerparser/'>this repository</a> on GitHub! If you use Glitch, remember to save the link to your project somewhere safe!\n"},
"bd7158d8c443edefaeb5bdef" : {"id":"bd7158d8c443edefaeb5bdef","title":"Timestamp Microservice","videoUrl":"","content":"\nBuild a full stack JavaScript app that is functionally similar to this: <a href='https://curse-arrow.glitch.me/' target='_blank'>https://curse-arrow.glitch.me/</a>.\nWorking on this project will involve you writing your code on Glitch on our starter project. After completing this project you can copy your public glitch url (to the homepage of your app) into this screen to test it! Optionally you may choose to write your project on another platform but it must be publicly visible for our testing.\nStart this project on Glitch using <a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-project-timestamp/' target='_blank'>this link</a> or clone <a href='https://github.com/freeCodeCamp/boilerplate-project-timestamp/'>this repository</a> on GitHub! If you use Glitch, remember to save the link to your project somewhere safe!\n"},
"bd7158d8c443edefaeb5bd0e" : {"id":"bd7158d8c443edefaeb5bd0e","title":"URL Shortener Microservice","videoUrl":"","content":"\nBuild a full stack JavaScript app that is functionally similar to this: <a href='https://thread-paper.glitch.me/' target='_blank'>https://thread-paper.glitch.me/</a>.\nWorking on this project will involve you writing your code on Glitch on our starter project. After completing this project you can copy your public glitch url (to the homepage of your app) into this screen to test it! Optionally you may choose to write your project on another platform but it must be publicly visible for our testing.\nStart this project on Glitch using <a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-project-urlshortener/' target='_blank'>this link</a> or clone <a href='https://github.com/freeCodeCamp/boilerplate-project-urlshortener/'>this repository</a> on GitHub! If you use Glitch, remember to save the link to your project somewhere safe!\n"},
"587d7fb1367417b2b2512bf4" : {"id":"587d7fb1367417b2b2512bf4","title":"Chain Middleware to Create a Time Server","videoUrl":"","content":"\nMiddleware can be mounted at a specific route using <code>app.METHOD(path, middlewareFunction)</code>. Middleware can also be chained inside route definition.\nLook at the following example:\n<blockquote>app.get('/user', function(req, res, next) {<br>  req.user = getTheUserSync();  // Hypothetical synchronous operation<br>  next();<br>}, function(req, res) {<br>  res.send(req.user);<br>})</blockquote>\nThis approach is useful to split the server operations into smaller units. That leads to a better app structure, and the possibility to reuse code in different places. This approach can also be used to perform some validation on the data. At each point of the middleware stack you can block the execution of the current chain and pass control to functions specifically designed to handle errors. Or you can pass control to the next matching route, to handle special cases. We will see how in the advanced Express section.\nIn the route <code>app.get('/now', ...)</code> chain a middleware function and the final handler. In the middleware function you should add the current time to the request object in the <code>req.time</code> key. You can use <code>new Date().toString()</code>. In the handler, respond with a JSON object, taking the structure <code>{time: req.time}</code>.\nHint: The test will not pass if you donât chain the middleware. If you mount the function somewhere else, the test will fail, even if the output result is correct.\n"},
"587d7fb2367417b2b2512bf8" : {"id":"587d7fb2367417b2b2512bf8","title":"Get Data from POST Requests","videoUrl":"","content":"\nMount a POST handler at the path <code>/name</code>. Itâs the same path as before. We have prepared a form in the html frontpage. It will submit the same data of exercise 10 (Query string). If the body-parser is configured correctly, you should find the parameters in the object <code>req.body</code>. Have a look at the usual library example:\n<blockquote>route: POST '/library'<br>urlencoded_body: userId=546&bookId=6754 <br>req.body: {userId: '546', bookId: '6754'}</blockquote>\nRespond with the same JSON object as before: <code>{name: 'firstname lastname'}</code>. Test if your endpoint works using the html form we provided in the app frontpage.\nTip: There are several other http methods other than GET and POST. And by convention there is a correspondence between the http verb, and the operation you are going to execute on the server. The conventional mapping is:\nPOST (sometimes PUT) - Create a new resource using the information sent with the request,\nGET - Read an existing resource without modifying it,\nPUT or PATCH (sometimes POST) - Update a resource using the data sent,\nDELETE => Delete a resource.\nThere are also a couple of other methods which are used to negotiate a connection with the server. Except from GET, all the other methods listed above can have a payload (i.e. the data into the request body). The body-parser middleware works with these methods as well.\n"},
"587d7fb2367417b2b2512bf6" : {"id":"587d7fb2367417b2b2512bf6","title":"Get Query Parameter Input from the Client","videoUrl":"","content":"\nAnother common way to get input from the client is by encoding the data after the route path, using a query string. The query string is delimited by a question mark (?), and includes field=value couples. Each couple is separated by an ampersand (&). Express can parse the data from the query string, and populate the object <code>req.query</code>. Some characters cannot be in URLs, they have to be encoded in a <a href='https://en.wikipedia.org/wiki/Percent-encoding' target='_blank'>different format</a> before you can send them. If you use the API from JavaScript, you can use specific methods to encode/decode these characters.\n<blockquote>route_path: '/library'<br>actual_request_URL: '/library?userId=546&bookId=6754' <br>req.query: {userId: '546', bookId: '6754'}</blockquote>\nBuild an API endpoint, mounted at <code>GET /name</code>. Respond with a JSON document, taking the structure <code>{ name: 'firstname lastname'}</code>. The first and last name parameters should be encoded in a query string e.g. <code>?first=firstname&last=lastname</code>.\nTIP: In the following exercise we are going to receive data from a POST request, at the same <code>/name</code> route path. If you want you can use the method <code>app.route(path).get(handler).post(handler)</code>. This syntax allows you to chain different verb handlers on the same path route. You can save a bit of typing, and have cleaner code.\n"},
"587d7fb2367417b2b2512bf5" : {"id":"587d7fb2367417b2b2512bf5","title":"Get Route Parameter Input from the Client","videoUrl":"","content":"\nWhen building an API, we have to allow users to communicate to us what they want to get from our service. For example, if the client is requesting information about a user stored in the database, they need a way to let us know which user they're interested in. One possible way to achieve this result is by using route parameters. Route parameters are named segments of the URL, delimited by slashes (/). Each segment captures the value of the part of the URL which matches its position. The captured values can be found in the <code>req.params</code> object.\n<blockquote>route_path: '/user/:userId/book/:bookId'<br>actual_request_URL: '/user/546/book/6754' <br>req.params: {userId: '546', bookId: '6754'}</blockquote>\nBuild an echo server, mounted at the route <code>GET /:word/echo</code>. Respond with a JSON object, taking the structure <code>{echo: word}</code>. You can find the word to be repeated at <code>req.params.word</code>. You can test your route from your browser's address bar, visiting some matching routes, e.g. your-app-rootpath/freecodecamp/echo\n"},
"587d7fb1367417b2b2512bf3" : {"id":"587d7fb1367417b2b2512bf3","title":"Implement a Root-Level Request Logger Middleware","videoUrl":"","content":"\nBefore we introduced the <code>express.static()</code> middleware function. Now itâs time to see what middleware is, in more detail. Middleware functions are functions that take 3 arguments: the request object, the response object, and the next function in the applicationâs request-response cycle. These functions execute some code that can have side effects on the app, and usually add informations to the request or response objects. They can also end the cycle sending the response, when some condition is met. If they donât send the response, when they are done they start the execution of the next function in the stack. This is triggered calling the 3rd argument <code>next()</code>. More information in the <a href='http://expressjs.com/en/guide/using-middleware.html' target='_blank'>express documentation</a>.\nLook at the following example :\n<blockquote>function(req, res, next) {<br>  console.log(\"I'm a middleware...\");<br>  next();<br>}</blockquote>\nLetâs suppose we mounted this function on a route. When a request matches the route, it displays the string âIâm a middlewareâ¦â. Then it executes the next function in the stack.\nIn this exercise we are going to build a root-level middleware. As we have seen in challenge 4, to mount a middleware function at root level we can use the method <code>app.use(&lt;mware-function&gt;)</code>. In this case the function will be executed for all the requests, but you can also set more specific conditions. For example, if you want a function to be executed only for POST requests, you could use <code>app.post(&lt;mware-function&gt;)</code>. Analogous methods exist for all the http verbs (GET, DELETE, PUT, â¦).\nBuild a simple logger. For every request, it should log in the console a string taking the following format: <code>method path - ip</code>. An example would look like: <code>GET /json - ::ffff:127.0.0.1</code>. Note that there is a space between <code>method</code> and <code>path</code> and that the dash separating <code>path</code> and <code>ip</code> is surrounded by a space on either side. You can get the request method (http verb), the relative route path, and the callerâs ip from the request object, using <code>req.method</code>, <code>req.path</code> and <code>req.ip</code>. Remember to call <code>next()</code> when you are done, or your server will be stuck forever. Be sure to have the âLogsâ opened, and see what happens when some request arrivesâ¦\nHint: Express evaluates functions in the order they appear in the code. This is true for middleware too. If you want it to work for all the routes, it should be mounted before them.\n"},
"587d7fb0367417b2b2512bed" : {"id":"587d7fb0367417b2b2512bed","title":"Meet the Node console","videoUrl":"","content":"\nDuring the development process, it is important to be able to check whatâs going on in your code. Node is just a JavaScript environment. Like client side JavaScript, you can use the console to display useful debug information. On your local machine, you would see the console output in a terminal. On Glitch you can open the logs in the lower part of the screen. You can toggle the log panel with the button âLogsâ (top-left, under the app name).\nTo get started, just print the classic \"Hello World\" in the console. We recommend to keep the log panel open while working at these challenges. Reading the logs you can be aware of the nature of the errors that may occur.\n"},
"587d7fb0367417b2b2512bef" : {"id":"587d7fb0367417b2b2512bef","title":"Serve an HTML File","videoUrl":"","content":"\nWe can respond with a file using the method <code>res.sendFile(path)</code>.\nYou can put it inside the <code>app.get('/', ...)</code> route handler. Behind the scenes this method will set the appropriate headers to instruct your browser on how to handle the file you want to send, according to its type. Then it will read and send the file. This method needs an absolute file path. We recommend you to use the Node global variable <code>__dirname</code> to calculate the path.\ne.g. <code>absolutePath = __dirname + relativePath/file.ext</code>.\nThe file to send is <code>/views/index.html</code>. Try to âShow Liveâ your app, you should see a big HTML heading (and a form that we will use laterâ¦), with no style applied.\nNote: You can edit the solution of the previous challenge, or create a new one. If you create a new solution, keep in mind that Express evaluates the routes from top to bottom. It executes the handler for the first match. You have to comment out the preceding solution, or the server will keep responding with a string.\n"},
"587d7fb1367417b2b2512bf1" : {"id":"587d7fb1367417b2b2512bf1","title":"Serve JSON on a Specific Route","videoUrl":"","content":"\nWhile an HTML server serves (you guessed it!) HTML, an API serves data. A <dfn>REST</dfn> (REpresentational State Transfer) API allows data exchange in a simple way, without the need for clients to know any detail about the server. The client only needs to know where the resource is (the URL), and the action it wants to perform on it (the verb). The GET verb is used when you are fetching some information, without modifying anything. These days, the preferred data format for moving information around the web is JSON. Simply put, JSON is a convenient way to represent a JavaScript object as a string, so it can be easily transmitted.\nLet's create a simple API by creating a route that responds with JSON at the path <code>/json</code>. You can do it as usual, with the <code>app.get()</code> method. Inside the route handler use the method <code>res.json()</code>, passing in an object as an argument. This method closes the request-response loop, returning the data. Behind the scenes it converts a valid JavaScript object into a string, then sets the appropriate headers to tell your browser that you are serving JSON, and sends the data back. A valid object has the usual structure <code>{key: data}</code>. Data can ba a number, a string, a nested object or an array. Data can also be a variable or the result of a function call; in which case it will be evaluated before being converted into a string.\nServe the object <code>{\"message\": \"Hello json\"}</code> as a response in JSON format, to the GET requests to the route <code>/json</code>. Then point your browser to your-app-url/json, you should see the message on the screen.\n"},
"587d7fb0367417b2b2512bf0" : {"id":"587d7fb0367417b2b2512bf0","title":"Serve Static Assets","videoUrl":"","content":"\nAn HTML server usually has one or more directories that are accessible by the user. You can place there the static assets needed by your application (stylesheets, scripts, images). In Express you can put in place this functionality using the middleware <code>express.static(path)</code>, where the parameter is the absolute path of the folder containing the assets. If you donât know what a middleware is, donât worry. Weâll discuss about it later in details. Basically middlewares are functions that intercept route handlers, adding some kind of information. A middleware needs to be mounted using the method <code>app.use(path, middlewareFunction)</code>. The first path argument is optional. If you donât pass it, the middleware will be executed for all the requests.\nMount the <code>express.static()</code> middleware for all the requests with <code>app.use()</code>. The absolute path to the assets folder is <code>__dirname + /public</code>.\nNow your app should be able to serve a CSS stylesheet. From outside the public folder will appear mounted to the root directory. Your front-page should look a little better now!\n"},
"587d7fb0367417b2b2512bee" : {"id":"587d7fb0367417b2b2512bee","title":"Start a Working Express Server","videoUrl":"","content":"\nIn the first two lines of the file myApp.js you can see how itâs easy to create an Express app object. This object has several methods, and we will learn many of them in these challenges. One fundamental method is <code>app.listen(port)</code>. It tells your server to listen on a given port, putting it in running state. You can see it at the bottom of the file. It is inside comments because for testing reasons we need the app to be running in background. All the code that you may want to add goes between these two fundamental parts. Glitch stores the port number in the environment variable <code>process.env.PORT</code>. Its value is <code>3000</code>.\nLetâs serve our first string! In Express, routes takes the following structure: <code>app.METHOD(PATH, HANDLER)</code>. METHOD is an http method in lowercase. PATH is a relative path on the server (it can be a string, or even a regular expression). HANDLER is a function that Express calls when the route is matched.\nHandlers take the form <code>function(req, res) {...}</code>, where req is the request object, and res is the response object. For example, the handler\n<blockquote>function(req, res) {<br> res.send('Response String');<br>}</blockquote>\nwill serve the string 'Response String'.\nUse the <code>app.get()</code> method to serve the string Hello Express, to GET requests matching the / root path. Be sure that your code works by looking at the logs, then see the results in your browser, clicking the button âShow Liveâ in the Glitch UI.\n"},
"587d7fb2367417b2b2512bf7" : {"id":"587d7fb2367417b2b2512bf7","title":"Use body-parser to Parse POST Requests","videoUrl":"","content":"\nBesides GET there is another common http verb, it is POST. POST is the default method used to send client data with HTML forms. In the REST convention POST is used to send data to create new items in the database (a new user, or a new blog post). We donât have a database in this project, but we are going to learn how to handle POST requests anyway.\nIn these kind of requests the data doesnât appear in the URL, it is hidden in the request body. This is a part of the HTML request, also called payload. Since HTML is text based, even if you donât see the data, it doesnât mean that they are secret. The raw content of an HTTP POST request is shown below:\n<blockquote>POST /path/subpath HTTP/1.0<br>From: john@example.com<br>User-Agent: someBrowser/1.0<br>Content-Type: application/x-www-form-urlencoded<br>Content-Length: 20<br>name=John+Doe&age=25</blockquote>\nAs you can see the body is encoded like the query string. This is the default format used by HTML forms. With Ajax we can also use JSON to be able to handle data having a more complex structure. There is also another type of encoding: multipart/form-data. This one is used to upload binary files.\nIn this exercise we will use an urlencoded body.\nTo parse the data coming from POST requests, you have to install a package: the body-parser. This package allows you to use a series of middleware, which can decode data in different formats. See the docs <a href=\"https://github.com/expressjs/body-parser\" target=\"_blank\" >here</a>.\nInstall the body-parser module in your package.json. Then require it at the top of the file. Store it in a variable named bodyParser.\nThe middleware to handle url encoded data is returned by <code>bodyParser.urlencoded({extended: false})</code>. <code>extended=false</code> is a configuration option that tells the parser to use the classic encoding. When using it, values can be only strings or arrays. The extended version allows more data flexibility, but it is outmatched by JSON. Pass to <code>app.use()</code> the function returned by the previous method call. As usual, the middleware must be mounted before all the routes which need it.\n"},
"587d7fb1367417b2b2512bf2" : {"id":"587d7fb1367417b2b2512bf2","title":"Use the .env File","videoUrl":"","content":"\nThe <code>.env</code> file is a hidden file that is used to pass environment variables to your application. This file is secret, no one but you can access it, and it can be used to store data that you want to keep private or hidden. For example, you can store API keys from external services or your database URI. You can also use it to store configuration options. By setting configuration options, you can change the behavior of your application, without the need to rewrite some code.\nThe environment variables are accessible from the app as <code>process.env.VAR_NAME</code>. The <code>process.env</code> object is a global Node object, and variables are passed as strings. By convention, the variable names are all uppercase, with words separated by an underscore. The <code>.env</code> is a shell file, so you donât need to wrap names or values in quotes. It is also important to note that there cannot be space around the equals sign when you are assigning values to your variables, e.g. <code>VAR_NAME=value</code>. Usually, you will put each variable definition on a separate line.\nLet's add an environment variable as a configuration option. Store the variable <code>MESSAGE_STYLE=uppercase</code> in the <code>.env</code> file. Then tell the GET <code>/json</code> route handler that you created in the last challenge to transform the response objectâs message to uppercase if <code>process.env.MESSAGE_STYLE</code> equals <code>uppercase</code>. The response object should become <code>{\"message\": \"HELLO JSON\"}</code>.\n"},
"587d7fb3367417b2b2512bfc" : {"id":"587d7fb3367417b2b2512bfc","title":"Add a Description to Your package.json","videoUrl":"","content":"\nThe next part of a good package.json is the description-field, where a short but informative description about your project belongs.\nIf you some day plan to publish a package to npm, remember that this is the string that should sell your idea to the user when they decide whether to install your package or not. However, thatâs not the only use case for the description: Itâs a great way to summarize what a project does, itâs just as important for your normal Node.js-projects to help other developers, future maintainers or even your future self understand the project quickly.\nRegardless of what you plan for your project, a description is definitely recommended. Letâs add something similar to this:\n<code>\"description\": \"A project that does something awesome\",</code>\nInstructions\nAdd a description to the package.json in your Glitch project.\nRemember to use double-quotes for field-names (\") and commas (,) to separate fields.\n"},
"587d7fb4367417b2b2512bfe" : {"id":"587d7fb4367417b2b2512bfe","title":"Add a License to Your package.json","videoUrl":"","content":"\nThe license-field is where you inform users of your project what they are allowed to do with it.\nSome common licenses for open source projects include MIT and BSD. http://choosealicense.com is a great resource if you want to learn more about what license could fit your project.\nLicense information is not required. Copyright laws in most countries will give you ownership of what you create by default. However, itâs always a good practice to explicitly state what users can and canât do.\nExample\n<code>\"license\": \"MIT\",</code>\nInstructions\nFill the license-field in the package.json of your Glitch project as you find suitable.\n"},
"587d7fb4367417b2b2512bff" : {"id":"587d7fb4367417b2b2512bff","title":"Add a Version to Your package.json","videoUrl":"","content":"\nThe version is together with name one of the required fields in a package.json. This field describes the current version of your project.\nExample\n<code>\"version\": \"1.2\",</code>\nInstructions\nAdd a version to the package.json in your Glitch project.\n"},
"587d7fb4367417b2b2512bfd" : {"id":"587d7fb4367417b2b2512bfd","title":"Add Keywords to Your package.json","videoUrl":"","content":"\nThe keywords-field is where you can describe your project using related keywords.\nExample\n<code>\"keywords\": [ \"descriptive\", \"related\", \"words\" ],</code>\nAs you can see, this field is structured as an array of double-quoted strings.\nInstructions\nAdd an array of suitable strings to the keywords-field in the package.json of your Glitch project.\nOne of the keywords should be freecodecamp.\n"},
"587d7fb4367417b2b2512c00" : {"id":"587d7fb4367417b2b2512c00","title":"Expand Your Project with External Packages from npm","videoUrl":"","content":"\nOne of the biggest reasons to use a package manager is their powerful dependency management. Instead of manually having to make sure that you get all dependencies whenever you set up a project on a new computer, npm automatically installs everything for you. But how can npm know exactly what your project needs? Meet the dependencies-section of your package.json.\nIn the dependencies-section, packages your project require are stored using the following format:\n<code>\"dependencies\": {</code>\n<code>  \"package-name\": \"version\",</code>\n<code>  \"express\": \"4.14.0\"</code>\n<code>}</code>\nInstructions\nAdd version 2.14.0 of the package moment to the dependencies-field of your package.json\nMoment is a handy library for working with time and dates.\n"},
"587d7fb3367417b2b2512bfb" : {"id":"587d7fb3367417b2b2512bfb","title":"'How to Use package.json, the Core of Any Node.js Project or npm Package'","videoUrl":"","content":"\nThe file package.json is the center of any Node.js project or npm package. It stores information about your project just like the &lt;head&gt;-section in a HTML document describes the content of a webpage. The package.json consists of a single JSON-object where information is stored in \"key\": value-pairs. There are only two required fields in a minimal package.json - name and version - but itâs a good practice to provide additional information about your project that could be useful to future users or maintainers.\nThe author-field\nIf you go to the Glitch project that you set up previously and look at on the left side of your screen, youâll find the file tree where you can see an overview of the various files in your project. Under the file treeâs back-end section, youâll find package.json - the file that weâll be improving in the next couple of challenges.\nOne of the most common pieces of information in this file is the author-field that specifies whoâs the creator of a project. It can either be a string or an object with contact details. The object is recommended for bigger projects but in our case, a simple string like the following example will do.\n<code>\"author\": \"Jane Doe\",</code>\nInstructions\nAdd your name to the author-field in the package.json of your Glitch project.\nRemember that youâre writing JSON.\nAll field-names must use double-quotes (\"), e.g. \"author\"\nAll fields must be separated with a comma (,)\n"},
"587d7fb5367417b2b2512c01" : {"id":"587d7fb5367417b2b2512c01","title":"Manage npm Dependencies By Understanding Semantic Versioning","videoUrl":"","content":"\nVersions of the npm packages in the dependencies-section of your package.json follow whatâs called Semantic Versioning (SemVer), an industry standard for software versioning aiming to make it easier to manage dependencies. Libraries, frameworks or other tools published on npm should use SemVer in order to clearly communicate what kind of changes that projects who depend on the package can expect if they update.\nSemVer doesnât make sense in projects without public APIs - so unless your project is similar to the examples above, use another versioning format.\nSo why do you need to understand SemVer?\nKnowing SemVer can be useful when you develop software that use external dependencies (which you almost always do). One day, your understanding of these numbers will save you from accidentally introducing breaking changes to your project without understanding why things âthat worked yesterdayâ suddenly donât.\nThis is how Semantic Versioning works according to the official website:\nGiven a version number MAJOR.MINOR.PATCH, increment the:\nMAJOR version when you make incompatible API changes,\nMINOR version when you add functionality in a backwards-compatible manner, and\nPATCH version when you make backwards-compatible bug fixes.\nThis means that PATCHes are bug fixes and MINORs add new features but neither of them break what worked before. Finally, MAJORs add changes that wonât work with earlier versions.\nExample\nA semantic version number: 1.3.8\nInstructions\nIn the dependencies-section of your package.json, change the version of moment to match MAJOR version 2, MINOR version 10 and PATCH version 2\n"},
"587d7fb5367417b2b2512c04" : {"id":"587d7fb5367417b2b2512c04","title":"Remove a Package from Your Dependencies","videoUrl":"","content":"\nNow youâve tested a few ways you can manage dependencies of your project by using the package.json's dependencies-section. Youâve included external packages by adding them to the file and even told npm what types of versions you want by using special characters as the tilde (~) or the caret (^).\nBut what if you want to remove an external package that you no longer need? You might already have guessed it - Just remove the corresponding \"key\": value-pair for that from your dependencies.\nThis same method applies to removing other fields in your package.json as well\nInstructions\nRemove the package moment from your dependencies.\nMake sure you have the right amount of commas after removing it.\n"},
"587d7fb5367417b2b2512c03" : {"id":"587d7fb5367417b2b2512c03","title":"Use the Caret-Character to Use the Latest Minor Version of a Dependency","videoUrl":"","content":"\nSimilar to how the tilde (~) we learned about in the last challenge allow npm to install the latest PATCH for a dependency, the caret (^) allows npm to install future updates as well. The difference is that the caret will allow both MINOR updates and PATCHes.\nAt the moment, your current version of moment should be ~2.10.2 which allows npm to install to the latest 2.10.x-version. If we instead were to use the caret (^) as our version prefix, npm would instead be allowed to update to any 2.x.x-version.\nExample\n<code>\"some-package-name\": \"^1.3.8\" allows updates to any 1.x.x version.</code>\nInstructions\nUse the caret-character (^) to prefix the version of moment in your dependencies and allow npm to update it to any new MINOR release.\nNote that the version numbers themselves not should be changed.\n"},
"587d7fb5367417b2b2512c02" : {"id":"587d7fb5367417b2b2512c02","title":"Use the Tilde-Character to Always Use the Latest Patch Version of a Dependency","videoUrl":"","content":"\nIn the last challenge, we told npm to only include a specific version of a package. Thatâs a useful way to freeze your dependencies if you need to make sure that different parts of your project stay compatible with each other. But in most use cases you donât want to miss bug fixes, since they often include important security patches and (hopefully) donât break things in doing so.\nTo allow a npm dependency to get updated to the latest PATCH-version, you can prefix the dependencyâs version with the tilde-character (~). In package.json, our current rule for how npm may upgrade moment is to use a specific version only (2.10.2), but we want to allow the latest 2.10.x-version.\nExample\n<code>\"some-package-name\": \"~1.3.8\" allows updates to any 1.3.x version.</code>\nInstructions\nUse the tilde-character (~) to prefix the version of moment in your dependencies and allow npm to update it to any new PATCH release.\nNote that the version numbers themselves not should be changed.\n"},
"587d7fb9367417b2b2512c12" : {"id":"587d7fb9367417b2b2512c12","title":"Chain Search Query Helpers to Narrow Search Results","videoUrl":"","content":"\nIf you donât pass the callback as the last argument to Model.find() (or to the other search methods), the query is not executed. You can store the query in a variable for later use. This kind of object enables you to build up a query using chaining syntax. The actual db search is executed when you finally chain the method .exec(). Pass your callback to this last method. There are many query helpers, here weâll use the most âfamousâ ones.\nFind people who like \"burrito\". Sort them by name, limit the results to two documents, and hide their age. Chain .find(), .sort(), .limit(), .select(), and then .exec(). Pass the done(err, data) callback to exec().\n"},
"587d7fb6367417b2b2512c07" : {"id":"587d7fb6367417b2b2512c07","title":"Create a Model","videoUrl":"","content":"\nFirst of all we need a Schema. Each schema maps to a MongoDB collection. It defines the shape of the documents within that collection.\nSchemas are building block for Models. They can be nested to create complex models, but in this case weâll keep things simple.\nA model allows you to create instances of your objects, called documents.\nCreate a person having this prototype :\n<code>- Person Prototype -</code>\n<code>--------------------</code>\n<code>name : string [required]</code>\n<code>age :  number</code>\n<code>favoriteFoods : array of strings (*) </code>\nUse the mongoose basic schema types. If you want you can also add\nmore fields, use simple validators like required or unique,\nand set default values. See the <a href='http://mongoosejs.com/docs/guide.html'>mongoose docs</a>.\n[C]RUD Part I - CREATE\nNote: Glitch is a real server, and in real servers the interactions with the db happen in handler functions. These function are executed when some event happens (e.g. someone hits an endpoint on your API). Weâll follow the same approach in these exercises. The done() function is a callback that tells us that we can proceed after completing an asynchronous operation such as inserting, searching, updating or deleting. Itâs following the Node convention and should be called as done(null, data) on success, or done(err) on error.\nWarning - When interacting with remote services, errors may occur !\n<code>/* Example */</code>\n<code>var someFunc = function(done) {</code>\n<code>  //... do something (risky) ...</code>\n<code>  if(error) return done(error);</code>\n<code>  done(null, result);</code>\n<code>};</code>\n"},
"587d7fb6367417b2b2512c09" : {"id":"587d7fb6367417b2b2512c09","title":"Create and Save a Record of a Model","videoUrl":"","content":"\nCreate a document instance using the Person constructor you built before. Pass to the constructor an object having the fields name, age, and favoriteFoods. Their types must be conformant to the ones in the Person Schema. Then call the method document.save() on the returned document instance. Pass to it a callback using the Node convention. This is a common pattern, all the following CRUD methods take a callback function like this as the last argument.\n<code>/* Example */</code>\n<code>// ...</code>\n<code>person.save(function(err, data) {</code>\n<code>//   ...do your stuff here...</code>\n<code>});</code>\n"},
"587d7fb7367417b2b2512c0a" : {"id":"587d7fb7367417b2b2512c0a","title":"Create Many Records with model.create()","videoUrl":"","content":"\nSometimes you need to create many instances of your models, e.g. when seeding a database with initial data. Model.create() takes an array of objects like [{name: 'John', ...}, {...}, ...] as the first argument, and saves them all in the db. Create many people with Model.create(), using the function argument arrayOfPeople.\n"},
"587d7fb8367417b2b2512c11" : {"id":"587d7fb8367417b2b2512c11","title":"Delete Many Documents with model.remove()","videoUrl":"","content":"\nModel.remove() is useful to delete all the documents matching given criteria. Delete all the people whose name is âMaryâ, using Model.remove(). Pass it to a query document with the ânameâ field set, and of course a callback.\nNote: Model.remove() doesnât return the deleted document, but a JSON object containing the outcome of the operation, and the number of items affected. Donât forget to pass it to the done() callback, since we use it in tests.\n"},
"587d7fb8367417b2b2512c10" : {"id":"587d7fb8367417b2b2512c10","title":"Delete One Document Using model.findByIdAndRemove","videoUrl":"","content":"\nDelete one person by her _id. You should use one of the methods findByIdAndRemove() or findOneAndRemove(). They are like the previous update methods. They pass the removed document to the cb. As usual, use the function argument personId as search key.\n"},
"587d7fb6367417b2b2512c06" : {"id":"587d7fb6367417b2b2512c06","title":"Install and Set Up Mongoose","videoUrl":"","content":"\nAdd mongodb and mongoose to the projectâs package.json. Then require mongoose. Store your mLab database URI in the private .env file as MONGO_URI. Connect to the database using mongoose.connect(<Your URI>)\n"},
"587d7fb8367417b2b2512c0e" : {"id":"587d7fb8367417b2b2512c0e","title":"'Perform Classic Updates by Running Find, Edit, then Save'","videoUrl":"","content":"\nIn the good old days this was what you needed to do if you wanted to edit a document and be able to use it somehow e.g. sending it back in a server response. Mongoose has a dedicated updating method : Model.update(). It is binded to the low-level mongo driver. It can bulk edit many documents matching certain criteria, but it doesnât send back the updated document, only a âstatusâ message. Furthermore it makes model validations difficult, because it just directly calls the mongo driver.\nFind a person by _id ( use any of the above methods ) with the parameter personId as search key. Add âhamburgerâ to the list of her favoriteFoods (you can use Array.push()). Then - inside the find callback - save() the updated Person.\n[*] Hint: This may be tricky if in your Schema you declared favoriteFoods as an Array, without specifying the type (i.e. [String]). In that casefavoriteFoods defaults to Mixed type, and you have to manually mark it as edited using document.markModified('edited-field'). (http://mongoosejs.com/docs/schematypes.html - #Mixed )\n"},
"587d7fb8367417b2b2512c0f" : {"id":"587d7fb8367417b2b2512c0f","title":"Perform New Updates on a Document Using model.findOneAndUpdate()","videoUrl":"","content":"\nRecent versions of mongoose have methods to simplify documents updating. Some more advanced features (i.e. pre/post hooks, validation) behave differently with this approach, so the Classic method is still useful in many situations. findByIdAndUpdate() can be used when searching by Id.\nFind a person by Name and set her age to 20. Use the function parameter personName as search key.\nHint: We want you to return the updated document. To do that you need to pass the options document { new: true } as the 3rd argument to findOneAndUpdate(). By default these methods return the unmodified object.\n"},
"587d7fb7367417b2b2512c0d" : {"id":"587d7fb7367417b2b2512c0d","title":"Use model.findById() to Search Your Database By _id","videoUrl":"","content":"\nWhen saving a document, mongodb automatically adds the field _id, and set it to a unique alphanumeric key. Searching by _id is an extremely frequent operation, so mongoose provides a dedicated method for it. Find the (only!!) person having a given _id, using Model.findById() -> Person. Use the function argument personId as search key.\n"},
"587d7fb7367417b2b2512c0c" : {"id":"587d7fb7367417b2b2512c0c","title":"Use model.findOne() to Return a Single Matching Document from Your Database","videoUrl":"","content":"\nModel.findOne() behaves like .find(), but it returns only one document (not an array), even if there are multiple items. It is especially useful when searching by properties that you have declared as unique. Find just one person which has a certain food in her favorites, using Model.findOne() -> Person. Use the function argument food as search key.\n"},
"587d7fb7367417b2b2512c0b" : {"id":"587d7fb7367417b2b2512c0b","title":"Use model.find() to Search Your Database","videoUrl":"","content":"\nFind all the people having a given name, using Model.find() -> [Person]\nIn its simplest usage, Model.find() accepts a query document (a JSON object ) as the first argument, then a callback. It returns an array of matches. It supports an extremely wide range of search options. Check it in the docs. Use the function argument personName as search key.\n"}}}
